
//#ifdef DF_WITH_KW

#define SENSORPORT PORTC
#define SENSORPIN PINC
#define SENSORDDR DDRC
#define SENSORPIN_WW PINC7
#define SENSORPIN_KW PINC6

#if 1
#define MYSYSLOG(arg)
#else
#define MYSYSLOG(arg) syslog_send_P(PSTR(arg));
#endif

CONTROL_START

ECMD_GLOBAL(dfmin, 100 / 20, uint16_t);    // 100ms
ECMD_GLOBAL(dfwait, 30000 / 20, uint16_t); // 30sec
ECMD_GLOBAL(wwcnt, 0, uint16_t);
ECMD_GLOBAL(kwcnt, 0, uint16_t);
ECMD_GLOBAL(wwstate, 0, uint8_t);
ECMD_GLOBAL(kwstate, 0, uint8_t);
ECMD_GLOBAL(dfreset, 0, uint8_t);

THREAD(watchcat)

static uint8_t ww_active = 0;
static uint8_t ww_on_time = 0;
static uint8_t ww_off_time = 0;

static uint8_t kw_active = 0;
static uint8_t kw_on_time = 0;
static uint8_t kw_off_time = 0;

static uint8_t sensor_ww_state = 0;
static uint8_t sensor_kw_state = 0;

/* Zustand:
 *
 *   0. war nicht gedrückt und ist nicht gedrückt
 *   1. war nicht gedrückt und ist gedrückt (steigende Flanke)
 *   2. war gedrückt und ist immer noch gedrückt
 *   3. war gedrückt und ist nicht mehr gedrückt (fallende Flanke)
 *
 */

char sensor_ww()
{
    if (wwstate == 0 && !(SENSORPIN & (1 << SENSORPIN_WW)))
    {
        // SENSORPIN_WW wird gedrueckt (steigende Flanke)
        wwstate = 1;
        // MYSYSLOG("C6 sensor_ww 1\n")
    }
    else if (wwstate == 1 && !(SENSORPIN & (1 << SENSORPIN_WW)))
    {
        // SENSORPIN_WW wird gehalten
        wwstate = 2;
        // MYSYSLOG("C6 sensor_ww 2\n")
    }
    else if (wwstate == 2 && (SENSORPIN & (1 << SENSORPIN_WW)))
    {
        // SENSORPIN_WW wird losgelassen (fallende Flanke)
        wwstate = 3;
        // MYSYSLOG("C6 sensor_ww 3\n")
    }
    else if (wwstate == 3 && (SENSORPIN & (1 << SENSORPIN_WW)))
    {
        // SENSORPIN_WW losgelassen
        wwstate = 0;
        // MYSYSLOG("C6 sensor_ww 0\n")
    }

    return wwstate;
}

char sensor_kw()
{
    if (kwstate == 0 && !(SENSORPIN & (1 << SENSORPIN_KW)))
    {
        // SENSORPIN_KW wird gedrueckt (steigende Flanke)
        kwstate = 1;
    }
    else if (kwstate == 1 && !(SENSORPIN & (1 << SENSORPIN_KW)))
    {
        // SENSORPIN_KW wird gehalten
        kwstate = 2;
    }
    else if (kwstate == 2 && (SENSORPIN & (1 << SENSORPIN_KW)))
    {
        // SENSORPIN_KW wird losgelassen (fallende Flanke)
        kwstate = 3;
    }
    else if (kwstate == 3 && (SENSORPIN & (1 << SENSORPIN_KW)))
    {
        // SENSORPIN_KW losgelassen
        kwstate = 0;
    }

    return kwstate;
}

if (dfreset > 0)
{
    dfreset = 0;

    ww_on_time = 0;
    kw_on_time = 0;

    ww_active = 0;
    kw_active = 0;

    wwstate = 0;
    kwstate = 0;

    wwcnt = 0;
    kwcnt = 0;

    ww_off_time = 0;
    kw_off_time = 0;
}

/* Zustand:
 *
 *   0. war nicht gedrückt und ist nicht gedrückt
 *   1. war nicht gedrückt und ist gedrückt (steigende Flanke)
 *   2. war gedrückt und ist immer noch gedrückt
 *   3. war gedrückt und ist nicht mehr gedrückt (fallende Flanke)
 *
 */

sensor_ww_state = sensor_ww();

if (sensor_ww_state == 0)
{
    if (ww_off_time)
        ww_off_time--;
}
else if (sensor_ww_state == 1)
{
    ww_on_time = 0;
}
else if (sensor_ww_state == 2)
{
    if (ww_off_time == 0)
    {
        ww_on_time++;

        if (ww_active == 0 && ww_on_time >= dfmin)
        {
            ww_active = 1;
            ESEND(192.168.178.10, "io set 248-WW 1");
            wwcnt++;
        }
    }
}
else if (sensor_ww_state == 3)
{
    if (ww_active == 1)
    {
        ESEND(192.168.178.10, "io set 248-WW 0");
        ww_active = 0;
        ww_on_time = 0;
        ww_off_time = dfwait;
    }
}

#ifdef DF_WITH_KW
sensor_kw_state = sensor_kw();

if (sensor_kw_state == 0)
{
    if (kw_off_time)
        kw_off_time--;
}
else if (sensor_kw_state == 1)
{
    kw_on_time = 0;
}
else if (sensor_kw_state == 2)
{
    if (kw_off_time == 0)
    {
        kw_on_time++;

        if (kw_active == 0 && kw_on_time > dfmin)
        {
            kw_active = 1;
            ESEND(192.168.178.10, "io set 248-KW 1");
            kwcnt++;
        }
    }
}
else if (sensor_kw_state == 3)
{
    if (kw_active == 1)
    {
        ESEND(192.168.178.10, "io set 248-KW 0");
        kw_active = 0;
        kw_on_time = 0;
        kw_off_time = dfwait;
    }
}
#endif

THREAD_END(watchcat)

#ifdef DF_WITH_KW
ON STARTUP DO SENSORPORT |= (_BV(SENSORPIN_KW) | _BV(SENSORPIN_WW)); // Pullup-Widerstände aktivieren
SENSORDDR &= ~(_BV(SENSORPIN_KW) | _BV(SENSORPIN_WW));               // Eingänge setzen
#else
ON STARTUP DO SENSORPORT |= (_BV(SENSORPIN_WW)); // Pullup-Widerstände aktivieren
SENSORDDR &= ~(_BV(SENSORPIN_WW));               // Eingänge setzen
#endif

THREAD_START(watchcat)

#ifdef DF_WITH_KW
SYSLOG("e6 248 C6 Durchflusserkennung KW/WW\n")
#else
SYSLOG("e6 248 C6 Durchflusserkennung WW\n")
#endif
END

    CONTROL_END
